argo-cd:
  fullnameOverride: argocd

  controller:
    replicas: 1
    enableStatefulSet: true
    extraArgs:
      - --repo-server-timeout-seconds
      - "500"
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
      rules:
        enabled: false
        spec:
          - alert: ArgoAppMissing
            expr: |
              absent(argocd_app_info)
            for: 15m
            labels:
              severity: critical
            annotations:
              summary: "[ArgoCD] No reported applications"
              description: >
                ArgoCD has not reported any applications data for the past 15 minutes which
                means that it must be down or not functioning properly.  This needs to be
                resolved for this cloud to continue to maintain state.
          - alert: ArgoAppNotSynced
            expr: |
              argocd_app_info{sync_status!="Synced"} == 1
            for: 12h
            labels:
              severity: warning
            annotations:
              summary: "[{{`{{$labels.name}}`}}] Application not synchronized"
              description: >
                The application [{{`{{$labels.name}}`}} has not been synchronized for over
                12 hours which means that the state of this cloud has drifted away from the
                state inside Git.
    
    resources:
      requests:
        cpu: 250m
        memory: 1Gi
  
  dex:
    enabled: false

  server:
    extraArgs:
      - --insecure

    rbac:
      create: true
      policy.default: role:readonly
      policy.csv: |
          g, dieterbocklandt@gmail.com, role:admin
      scopes: '[email, group]'

    ingress:
      enabled: true
      ingressClassName: traefik
      annotations:
        traefik.ingress.kubernetes.io/router.entrypoints: websecure
        traefik.ingress.kubernetes.io/router.priority: "10"
        cert-manager.io/cluster-issuer: letsencrypt-prod
      hosts:
        - argocd.siliconsheep.se
      tls:
        - secretName: argocd-siliconsheep-se
          hosts: [argocd.siliconsheep.se]
    
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
    resources:
      requests:
        cpu: 100m
        memory: 100Mi
  
  repoServer:
    autoscaling:
      enabled: true
      minReplicas: 1
      maxReplicas: 5
      targetCPUUtilizationPercentage: 75
      targetMemoryUtilizationPercentage: 75
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  app.kubernetes.io/name: argocd-repo-server
              topologyKey: kubernetes.io/hostname
            weight: 100
    resources:
      requests:
        cpu: 100m
        memory: 200Mi
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
    env:
      - name: "ARGOCD_EXEC_TIMEOUT"
        value: "5m"
    # initContainers:
    #   - name: download-istioctl
    #     image: alpine:3
    #     command: [ sh, -c ]
    #     env:
    #       - name: ISTIO_VERSION
    #         value: "1.16.0"
    #     args:
    #       - apk add curl &&
    #         curl -L https://istio.io/downloadIstio | sh - &&
    #         cp ${ISTIO_VERSION}/bin/istioctl /custom-tools/istioctl
    #     volumeMounts:
    #       - mountPath: /custom-tools
    #         name: custom-tools
    # volumes:
    #   - name: custom-tools
    #     emptyDir: { }
    # volumeMounts:
    #   - mountPath: /usr/local/bin/istioctl
    #     name: custom-tools
    #     subPath: istioctl
  
  applicationSet:
    enabled: true
    fullnameOverride: applicationset
    args:
      policy: sync
  
  configs:
    cm:
      admin.enabled: "true"
      url: https://argocd.siliconsheep.se
      resource.compareoptions: |
        ignoreAggregatedRoles: true
      resource.customizations.health.certmanager.k8s.io-Certificate: |
        hs = {}
        if obj.status ~= nil then
          if obj.status.conditions ~= nil then
            for i, condition in ipairs(obj.status.conditions) do
              if condition.type == "Ready" and condition.status == "False" then
                hs.status = "Degraded"
                hs.message = condition.message
                return hs
              end
              if condition.type == "Ready" and condition.status == "True" then
                hs.status = "Healthy"
                hs.message = condition.message
                return hs
              end
            end
          end
        end
        hs.status = "Progressing"
        hs.message = "Waiting for certificate"
        return hs
      resource.customizations.health.cert-manager.io_Certificate: |
        hs = {}
        if obj.status ~= nil then
          if obj.status.conditions ~= nil then
            for i, condition in ipairs(obj.status.conditions) do
              if condition.type == "Ready" and condition.status == "False" then
                hs.status = "Degraded"
                hs.message = condition.message
                return hs
              end
              if condition.type == "Ready" and condition.status == "True" then
                hs.status = "Healthy"
                hs.message = condition.message
                return hs
              end
            end
          end
        end
        hs.status = "Progressing"
        hs.message = "Waiting for certificate"
        return hs
      resource.customizations.health.argoproj.io_Application: |
        hs = {}
        hs.status = "Progressing"
        hs.message = ""
        if obj.status ~= nil then
          if obj.status.health ~= nil then
            hs.status = obj.status.health.status
            if obj.status.health.message ~= nil then
              hs.message = obj.status.health.message
            end
          end
        end
        return hs
      resource.customizations.health.Service: |
        hs = {}
        hs.status = "Healthy"
        return hs
      resource.customizations.health.networking.k8s.io_Ingress: |
        hs = {}
        hs.status = "Healthy"
        return hs
      resource.customizations.ignoreDifferences.admissionregistration.k8s.io_MutatingWebhookConfiguration: |
        jqPathExpressions:
        - '.webhooks[]?.clientConfig.caBundle'
        - '.webhooks[]?.failurePolicy'
      resource.customizations.ignoreDifferences.admissionregistration.k8s.io_ValidatingWebhookConfiguration: |
        jqPathExpressions:
        - '.webhooks[]?.clientConfig.caBundle'
        - '.webhooks[]?.failurePolicy'